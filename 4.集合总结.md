# 集合

`集合`在数学领域表示“各种各样的事物的总和”, 在数据库领域表示记录的集合. 具体来说,表、视图和查询的执行结果都是记录的集合, 其中的元素为表或者查询结果中的每一行。

在标准 SQL 中, 分别对检索结果使用 `UNION`, `INTERSECT,` `EXCEPT` 来将检索结果进行并,交和差运算, 像`UNION`,`INTERSECT`, `EXCEPT`这种用来进行集合运算的运算符称为集合运算符。

学习集合时，我们和数学上的 交集、并集、补集做下对比。

在数据库中, 所有的表--以及查询结果--都可以视为集合, 因此也可以把表视为集合进行上述集合运算, 在很多时候, 这种抽象非常有助于对复杂查询问题给出一个可行的思路。

## 1. 内连接

```sql
表a inner join 表b on(条件)
```

中间没有 outer。

## 2. 外连接

- 左外连接

```sql
表a  left (outer) join 表b on(条件)
```

其中outer可以省略。以表a为基准。

- 右外连接

```sql
表a  right (outer) join 表b on(条件)
```

是以表b为基准等价于：

```sql
表b  left (outer) join 表a on(条件)
```

我们建如下表：

```sql
CREATE TABLE product2(
	product_id CHAR(4) NOT NULL,
 	product_name VARCHAR(100) NOT NULL,
 	product_type VARCHAR(32) NOT NULL,
 	sale_price INTEGER ,
 	purchase_price INTEGER ,
 	regist_date DATE ,
 	PRIMARY KEY (product_id)
);
insert into `product2` values('0001', 'T恤衫', '衣服', 1000, 500, '2009-09-20'),
('0002', '打孔器', '办公用品', 500, 320, '2009-09-11'),
('0003', '运动T恤', '衣服', 4000, 2800, NULL),
('0009', '手表', '运动用品', 1000, 500, '2022-04-20'),
('0010', '水壶', '家庭用品', 1000, 500, '2022-04-20');
```

```sql
mysql> select * from product;
+------------+--------------+--------------+------------+----------------+-------------+
| product_id | product_name | product_type | sale_price | purchase_price | regist_date |
+------------+--------------+--------------+------------+----------------+-------------+
| 0001       | T恤衫        | 衣服         |       1000 |            500 | 2009-09-20  |
| 0002       | 打孔器       | 办公用品     |        500 |            320 | 2009-09-11  |
| 0003       | 运动T恤      | 衣服         |       4000 |           2800 | NULL        |
| 0004       | 菜刀         | 厨房用具     |       3000 |           2800 | 2009-09-20  |
| 0005       | 高压锅       | 厨房用具     |       6800 |           5000 | 2009-01-15  |
| 0006       | 叉子         | 厨房用具     |        500 |           NULL | 2009-09-20  |
| 0007       | 擦菜板       | 厨房用具     |        880 |            790 | 2008-04-28  |
| 0008       | 圆珠笔       | 办公用品     |       5000 |           NULL | 2009-11-11  |
+------------+--------------+--------------+------------+----------------+-------------+
8 rows in set (0.02 sec)

mysql> select * from product2;
+------------+--------------+--------------+------------+----------------+-------------+
| product_id | product_name | product_type | sale_price | purchase_price | regist_date |
+------------+--------------+--------------+------------+----------------+-------------+
| 0001       | T恤衫        | 衣服         |       1000 |            500 | 2009-09-20  |
| 0002       | 打孔器       | 办公用品     |        500 |            320 | 2009-09-11  |
| 0003       | 运动T恤      | 衣服         |       4000 |           2800 | NULL        |
| 0009       | 手表         | 运动用品     |       1000 |            500 | 2022-04-20  |
| 0010       | 水壶         | 家庭用品     |       1000 |            500 | 2022-04-20  |
+------------+--------------+--------------+------------+----------------+-------------+
5 rows in set (0.00 sec)
```

用关联子查询实现：在 product 表中，取出 product_id, product_name, sale_price, 并按照商品的售价从低到高进行排序、对售价进行累计求和。

```sql
-- 方法一：关联子查询
SELECT
	a.product_id,
	a.product_name,
	a.sale_price,
	(
		SELECT
			count(1)
		FROM
			product b
		WHERE
			b.sale_price < a.sale_price
		OR (
			b.sale_price = a.sale_price
			AND b.product_id <> a.product_id
		)
	) rank_num,
	(
		SELECT
			sum(b.sale_price)
		FROM
			product b
		WHERE
			(
				b.sale_price = a.sale_price
				AND b.product_id <= a.product_id
			)
		OR (b.sale_price < a.sale_price)
	) sum_sale_price
FROM
	product a
ORDER BY
	rank_num, rank_num;
	
+------------+--------------+------------+----------+----------------+
| product_id | product_name | sale_price | rank_num | sum_sale_price |
+------------+--------------+------------+----------+----------------+
| 0002       | 打孔器       |        500 |        1 |            500 |
| 0006       | 叉子         |        500 |        1 |           1000 |
| 0007       | 擦菜板       |        880 |        2 |           1880 |
| 0001       | T恤衫        |       1000 |        3 |           2880 |
| 0004       | 菜刀         |       3000 |        4 |           5880 |
| 0003       | 运动T恤      |       4000 |        5 |           9880 |
| 0008       | 圆珠笔       |       5000 |        6 |          14880 |
| 0005       | 高压锅       |       6800 |        7 |          21680 |
+------------+--------------+------------+----------+----------------+
8 rows in set (0.00 sec)
```



```sql
-- 方法二：
-- 窗口函数实现
SELECT
	a.*, (
		dense_rank () over (
			PARTITION BY product_type
			ORDER BY
				sale_price
		)
	) rank_num,
	SUM(sale_price) over (

		ORDER BY
			sale_price ROWS BETWEEN 8 preceding
		AND current ROW
	) sum_sale_price
FROM
	product a;
	
+------------+--------------+--------------+------------+----------------+-------------+----------+----------------+
| product_id | product_name | product_type | sale_price | purchase_price | regist_date | rank_num | sum_sale_price |
+------------+--------------+--------------+------------+----------------+-------------+----------+----------------+
| 0002       | 打孔器       | 办公用品     |        500 |            320 | 2009-09-11  |        1 |            500 |
| 0006       | 叉子         | 厨房用具     |        500 |           NULL | 2009-09-20  |        1 |           1000 |
| 0007       | 擦菜板       | 厨房用具     |        880 |            790 | 2008-04-28  |        2 |           1880 |
| 0001       | T恤衫        | 衣服         |       1000 |            500 | 2009-09-20  |        1 |           2880 |
| 0004       | 菜刀         | 厨房用具     |       3000 |           2800 | 2009-09-20  |        3 |           5880 |
| 0003       | 运动T恤      | 衣服         |       4000 |           2800 | NULL        |        2 |           9880 |
| 0008       | 圆珠笔       | 办公用品     |       5000 |           NULL | 2009-11-11  |        2 |          14880 |
| 0005       | 高压锅       | 厨房用具     |       6800 |           5000 | 2009-01-15  |        4 |          21680 |
+------------+--------------+--------------+------------+----------------+-------------+----------+----------------+
8 rows in set (0.00 sec)
```

注意：以下代码出现问题，价格相同时得到的是所有相同价格的和。

```sql
SELECT
	a.*, (
		dense_rank () over (
			PARTITION BY product_type
			ORDER BY
				sale_price
		)
	) rank_num,
	SUM(sale_price) over (

		ORDER BY
			sale_price
	) sum_sale_price
FROM
	product a;

+------------+--------------+--------------+------------+----------------+-------------+----------+----------------+
| product_id | product_name | product_type | sale_price | purchase_price | regist_date | rank_num | sum_sale_price |
+------------+--------------+--------------+------------+----------------+-------------+----------+----------------+
| 0002       | 打孔器       | 办公用品     |        500 |            320 | 2009-09-11  |        1 |           1000 |
| 0006       | 叉子         | 厨房用具     |        500 |           NULL | 2009-09-20  |        1 |           1000 |
| 0007       | 擦菜板       | 厨房用具     |        880 |            790 | 2008-04-28  |        2 |           1880 |
| 0001       | T恤衫        | 衣服         |       1000 |            500 | 2009-09-20  |        1 |           2880 |
| 0004       | 菜刀         | 厨房用具     |       3000 |           2800 | 2009-09-20  |        3 |           5880 |
| 0003       | 运动T恤      | 衣服         |       4000 |           2800 | NULL        |        2 |           9880 |
| 0008       | 圆珠笔       | 办公用品     |       5000 |           NULL | 2009-11-11  |        2 |          14880 |
| 0005       | 高压锅       | 厨房用具     |       6800 |           5000 | 2009-01-15  |        4 |          21680 |
+------------+--------------+--------------+------------+----------------+-------------+----------+----------------+
8 rows in set (0.00 sec)
```

