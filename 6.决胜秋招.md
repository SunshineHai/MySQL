# 决胜秋招

## SectionA

### 练习1： 各部门工资最高的员工（难度：中等）

创建Employee 表，包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。

```sql
+----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Henry | 80000  | 2            |
| 3  | Sam   | 60000  | 2            |
| 4  | Max   | 90000  | 1            |
+----+-------+--------+--------------+
```

```sql
DROP TABLE IF EXISTS `employee`;
CREATE TABLE `employee` (
	`id` INTEGER PRIMARY KEY NOT NULL AUTO_increment COMMENT 'ID',
	`NAME` VARCHAR (40) DEFAULT '' COMMENT '姓名',
	`salary` INT DEFAULT NULL COMMENT '薪水',
	`department_id` INTEGER NOT NULL,
	FOREIGN KEY (department_id) REFERENCES department (department_id)
);

INSERT INTO `employee` (
	`name`,
	`salary`,
	`department_id`
)
VALUES
	('Joe', 70000, 1),
	('Henry', 80000, 2),
	('Sam', 60000, 2),
	('Max', 90000, 1);
```

创建Department 表，包含公司所有部门的信息。

```sql
+---------------+-----------------+
| department_id | department_name |
+---------------+-----------------+
|             1 | IT              |
|             2 | Sales           |
|             3 | 后勤部          |
+---------------+-----------------+
3 rows in set (0.00 sec)
```

```sql
DROP TABLE
IF EXISTS `department`;

CREATE TABLE `department` (
    department_id 		  integer not null primary key auto_increment comment '部门id',
    department_name		  varchar(40) default '' comment '部门名称'
);
```

编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。

```sql
+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| Sales      | Henry    | 80000  |
+------------+----------+--------+

-- 方法一：使用窗口函数
WITH t AS (
	SELECT
		a. NAME,
		a.salary,
		a.department_id,
		b.department_name,
		(
			rank () over (
				PARTITION BY a.department_id
				ORDER BY
					salary DESC
			)
		) ranking
	FROM
		employee a
	INNER JOIN department b ON a.department_id = b.department_id
) SELECT
	department_name,
	`NAME`,
	salary
FROM
	t
WHERE
	ranking = 1;
	
-- 方法二：使用传统的 group by 太麻烦，不写了

```

### 练习2: 换座位（难度：中等）

小美是一所中学的信息科技老师，她有一张 seat 座位表，平时用来储存学生名字和与他们相对应的座位 id。

其中纵列的**id**是连续递增的

小美想改变相邻俩学生的座位。

你能不能帮她写一个 SQL query 来输出小美想要的结果呢？

请创建如下所示seat表：

**示例：**

```sql
+---------+---------+
|    id   | student |
+---------+---------+
|    1    | Abbot   |
|    2    | Doris   |
|    3    | Emerson |
|    4    | Green   |
|    5    | Jeames  |
+---------+---------+
```

假如数据输入的是上表，则输出结果如下：

```sql
+---------+---------+
|    id   | student |
+---------+---------+
|    1    | Doris   |
|    2    | Abbot   |
|    3    | Green   |
|    4    | Emerson |
|    5    | Jeames  |
+---------+---------+
```

**注意：** 如果学生人数是奇数，则不需要改变最后一个同学的座位。

答：

```sql
DROP TABLE
IF EXISTS `seat`;

CREATE TABLE `seat` (
    `id` 		  integer not null primary key auto_increment comment '座位号',
    `student`		  varchar(40) default '' comment '学生姓名'
);

SELECT * FROM seat;

INSERT INTO `seat` (`student`)
VALUES
	('Abbot'),
	('Doris'),
	('Emerson'),
	('Green'),
	('Jeames');
	
+----+---------+
| id | student |
+----+---------+
|  1 | Abbot   |
|  2 | Doris   |
|  3 | Emerson |
|  4 | Green   |
|  5 | Jeames  |
+----+---------+
5 rows in set (0.00 sec)

-- id 为奇数，显示下一条的 id 的Student， id 为偶数，则显示上一条的Student， 记录为奇数，则最后一条记录显示不变


SELECT
	id,
	(
		CASE
		WHEN a.id & 1 THEN
			IFNULL(
				(
					SELECT
						student
					FROM
						seat
					WHERE
						id = a.id + 1
				),
				a.student
			)
		ELSE
			(
				SELECT
					student
				FROM
					seat
				WHERE
					id = a.id - 1
			)
		END
	) student
FROM
	seat a;

# 一个数 按位与(&) 1 = 0 : 该数为偶数，否则为奇数
SELECT 7&1
SELECT IfNULL(1/0, 10) 

+----+---------+
| id | student |
+----+---------+
|  1 | Doris   |
|  2 | Abbot   |
|  3 | Green   |
|  4 | Emerson |
|  5 | Jeames  |
+----+---------+
5 rows in set (0.00 sec)
```

### 练习3: 分数排名（难度：中等）

假设在某次期末考试中，二年级四个班的平均成绩分别是 `93、93、93、91`，请问可以实现几种排名结果？分别使用了什么函数？排序结果是怎样的？（只考虑降序）

```sql
+-------+-----------+
| class | score_avg |
+-------+-----------+
|    1  |       93  |
|    2  |       93  |
|    3  |       93  |
|    4  |       91  |
+-------+-----------+
```



```sql
-- 建表
DROP TABLE
IF EXISTS `grade`;

CREATE TABLE `grade` (
    class_id 		  integer not null primary key auto_increment comment '班级id',
    score_avg		  integer comment '平均成绩'
);



SELECT
	*
FROM
	grade;


INSERT INTO `grade`(score_avg)
VALUES
	(93),
	(93),
	(93),
	(91);
	
SELECT
	a.class_id,
	a.score_avg,
	rank() over w 'rank',
  	dense_rank() over w 'dense_rank',
	row_number() over w 'row_number'
FROM
	grade a
window w AS (ORDER BY score_avg DESC);

+----------+-----------+------+------------+------------+
| class_id | score_avg | rank | dense_rank | row_number |
+----------+-----------+------+------------+------------+
|        1 |        93 |    1 |          1 |          1 |
|        2 |        93 |    1 |          1 |          2 |
|        3 |        93 |    1 |          1 |          3 |
|        4 |        91 |    4 |          2 |          4 |
+----------+-----------+------+------------+------------+
4 rows in set (0.00 sec)
```

由以上结果可知，使用dense_rank() 函数即可求出排名。

### 练习四：连续出现的数字（难度：中等）

编写一个 SQL 查询，查找所有至少连续出现三次的数字。

```sql
+----+-----+
| Id | Num |
+----+-----+
| 1  |  1  |
| 2  |  1  |
| 3  |  1  |
| 4  |  2  |
| 5  |  1  |
| 6  |  2  |
| 7  |  2  |
+----+-----+
```

例如，给定上面的 Logs 表， 1 是唯一连续出现至少三次的数字。

```sql
+-----------------+
| ConsecutiveNums |
+-----------------+
| 1               |
+-----------------+
```



```sql
-- 建表
DROP TABLE
IF EXISTS `test`;

CREATE TABLE `test` (
    `id` 		  integer not null primary key auto_increment,
    `num`		  integer
);



SELECT
	*
FROM
	test;


INSERT INTO `test`(`num`)
VALUES
	(1),
	(1),
	(1),
	(2),
	(1),
	(2),
	(2);
	
-- 解答：
WITH t AS (
	SELECT
		num,
		@prev,
		@cnt,
		(
			CASE
			WHEN @prev = num THEN
				@cnt := @cnt + 1     # 1.prev 保存前一个 num 值，初始值为 NULL
			WHEN (@prev := num) IS NOT NULL THEN
				@cnt := 1            # 2.num 中有值，则赋值给 prev, 然后 cnt 记为1
			END
		) 'count'
	FROM
		test,
		(
			SELECT
				@prev := NULL,
				@cnt := NULL
		) temp
) SELECT
	num
FROM
	t
WHERE
	count >= 3;


+------+
| num  |
+------+
|    1 |
+------+
1 row in set, 5 warnings (0.00 sec)
```

注意：

-- 定义2个变量 prev、cnt, prev 存储前一个 的 num 值, cnt 记录 连续的 num 的个数
/*
	注意： 
			  1.SQL中， 定义变量使用 @变量名
				2.因为 = 在SQL中是判断数学上的 是否相等，因此 赋值 使用 :=
			
*/
select @prev = 10 AS prev;

总结：此题需要用到 的语法：

- MySQL中变量的定义
- 赋值的使用： := 和 = 的区别
- 对每一行的num进行计数

### 练习五：树节点 （难度：中等）

对于**tree**表，*id*是树节点的标识，*p_id*是其父节点的*id*。

```sql
+----+------+
| id | p_id |
+----+------+
| 1  | null |
| 2  | 1    |
| 3  | 1    |
| 4  | 2    |
| 5  | 2    |
+----+------+
```

每个节点都是以下三种类型中的一种：

- Root: 如果节点是根节点。
- Leaf: 如果节点是叶子节点。
- Inner: 如果节点既不是根节点也不是叶子节点。

写一条查询语句打印节点id及对应的节点类型。按照节点id排序。上面例子的对应结果为：

```sql
+----+------+
| id | Type |
+----+------+
| 1  | Root |
| 2  | Inner|
| 3  | Leaf |
| 4  | Leaf |
| 5  | Leaf |
+----+------+
```

**说明**

- 节点’1’是根节点，因为它的父节点为NULL，有’2’和’3’两个子节点。
- 节点’2’是内部节点，因为它的父节点是’1’，有子节点’4’和’5’。
- 节点’3’，‘4’，'5’是叶子节点，因为它们有父节点但没有子节点。

下面是树的图形：

```
    1         
  /   \ 
 2    3    
/ \
4  5
```

**注意**

如果一个树只有一个节点，只需要输出根节点属性。

**分析：**

根节点：没有父节点

内部节点：有父节点，也有子节点

叶子节点：只有父节点，没有子节点。

```sql
-- 建表
DROP TABLE
IF EXISTS `tree`;

CREATE TABLE `tree` (
    `id` 		  integer not null primary key auto_increment,
    `p_id`		integer
);



SELECT
	*
FROM
	tree;


INSERT INTO `tree`(`p_id`)
VALUES
	(NULL),
	(1),
	(1),
	(2),
	(2);
	
-- 解答：
SELECT
	id,
	(
		CASE
		WHEN p_id IS NULL THEN
			'Root'
		WHEN p_id IS NOT NULL
		AND EXISTS (
			SELECT
				1
			FROM
				tree b
			WHERE
				b.p_id = a.id
		) THEN
			'Inner'
		WHEN a.p_id IS NOT NULL
		AND NOT EXISTS (
			SELECT
				1
			FROM
				tree b
			WHERE
				b.p_id = a.id
		) THEN
			'Leaf'
		END
	) 'type'
FROM
	tree a;

+----+-------+
| id | type  |
+----+-------+
|  1 | Root  |
|  2 | Inner |
|  3 | Leaf  |
|  4 | Leaf  |
|  5 | Leaf  |
+----+-------+
5 rows in set (0.00 sec)
```

以上case 语句中的 3个条件完全是根据分析实现的。

### 练习六：至少有五名直接下属的经理 （难度：中等）

**Employee**表包含所有员工及其上级的信息。每位员工都有一个Id，并且还有一个对应主管的Id（ManagerId）。

```sql
+------+----------+-----------+----------+
|Id    |Name 	  |Department |ManagerId |
+------+----------+-----------+----------+
|101   |John 	  |A 	      |null      |
|102   |Dan 	  |A 	      |101       |
|103   |James 	  |A 	      |101       |
|104   |Amy 	  |A 	      |101       |
|105   |Anne 	  |A 	      |101       |
|106   |Ron 	  |B 	      |101       |
+------+----------+-----------+----------+
```

针对**Employee**表，写一条SQL语句找出有5个下属的主管。对于上面的表，结果应输出：

```sql
+-------+
| Name  |
+-------+
| John  |
+-------+
```

**注意:**

没有人向自己汇报。

```sql
SELECT * FROM employee;

-- 建表
INSERT INTO `employee`(id, `name`, salary, department_id, manage_id)
VALUES
	(101, 'John', NULL, 01, NULL),
	(102, 'Dan', NULL, 01, 101),
	(103, 'James', NULL, 01, 101),
	(104, 'Amy', NULL, 01, 101),
	(105, 'Anne', NULL, 01, 101),
	(106, 'Ron', NULL, 01, 101);
	
SELECT
	`name`
FROM
	employee
WHERE
	id IN (
		SELECT
			manage_id
		FROM
			employee a
		GROUP BY
			manage_id
		HAVING
			count(1) = 5
	);

+------+
| name |
+------+
| John |
+------+
1 row in set (0.00 sec)
```

### 练习七：查询回答率最高的问题 （难度：中等）

求出**survey_log**表中回答率最高的问题，表格的字段有：**uid, action, question_id, answer_id, q_num, timestamp**。

uid是用户id；action的值为：“show”， “answer”， “skip”；当action是"answer"时，answer_id不为空，相反，当action是"show"和"skip"时为空（null）；q_num是问题的数字序号。

写一条sql语句找出回答率最高的 `question_id`。

**举例：**

**输入**

| uid  | action | question_id | answer_id | q_num | timestamp |
| ---- | ------ | ----------- | --------- | ----- | --------- |
| 5    | show   | 285         | null      | 1     | 123       |
| 5    | answer | 285         | 124124    | 1     | 124       |
| 5    | show   | 369         | null      | 2     | 125       |
| 5    | skip   | 369         | null      | 2     | 126       |

**输出**

| question_id |
| ----------- |
| 285         |

**说明**

问题285的回答率为1/1，然而问题369的回答率是0/1，所以输出是285。

**注意：**

最高回答率的意思是：同一个问题出现的次数中回答的比例。

### 练习八：各部门前3高工资的员工（难度：中等）

将练习一中的 `employee` 表清空，重新插入以下数据（也可以复制练习一中的 `employee` 表，再插入第5、第6行数据）：

```sql
+----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Henry | 80000  | 2            |
| 3  | Sam   | 60000  | 2            |
| 4  | Max   | 90000  | 1            |
| 5  | Janet | 69000  | 1            |
| 6  | Randy | 85000  | 1            |
+----+-------+--------+--------------+
```

编写一个 SQL 查询，找出每个部门工资前三高的员工。例如，根据上述给定的表格，查询结果应返回：

```sql
+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| IT         | Randy    | 85000  |
| IT         | Joe      | 70000  |
| Sales      | Henry    | 80000  |
| Sales      | Sam      | 60000  |
+------------+----------+--------+
```

此外，请考虑实现各部门前N高工资的员工功能。

答：

```sql
truncate employee;

INSERT INTO `employee` (
	`name`,
	`salary`,
	`department_id`
)
VALUES
	('Joe', 70000, 1),
	('Henry', 80000, 2),
	('Sam', 60000, 2),
	('Max', 90000, 1),
	('Janet', 69000, 1),
	('Randy', 85000, 1);
	
mysql> select * from employee;
+----+-------+--------+---------------+-----------+
| id | NAME  | salary | department_id | manage_id |
+----+-------+--------+---------------+-----------+
|  1 | Joe   |  70000 |             1 |      NULL |
|  2 | Henry |  80000 |             2 |      NULL |
|  3 | Sam   |  60000 |             2 |      NULL |
|  4 | Max   |  90000 |             1 |      NULL |
|  5 | Janet |  69000 |             1 |      NULL |
|  6 | Randy |  85000 |             1 |      NULL |
+----+-------+--------+---------------+-----------+
6 rows in set (0.00 sec)

WITH
t
AS
(SELECT
	e.id,
	e. NAME,
	e.salary,
	(select department_name from department where department_id = e.department_id) 'department_name',
	rank () over w 'ranking'
FROM
	employee e 
	window w AS (
		PARTITION BY department_id
		ORDER BY
			salary DESC
	)
)SELECT * FROM t where t.ranking <= 3;

+----+-------+--------+-----------------+---------+
| id | NAME  | salary | department_name | ranking |
+----+-------+--------+-----------------+---------+
|  4 | Max   |  90000 | IT              |       1 |
|  6 | Randy |  85000 | IT              |       2 |
|  1 | Joe   |  70000 | IT              |       3 |
|  2 | Henry |  80000 | Sales           |       1 |
|  3 | Sam   |  60000 | Sales           |       2 |
+----+-------+--------+-----------------+---------+
5 rows in set (0.00 sec)
```

请考虑实现各部门前N高工资的员工功能:

可以把 where t.ranking <= 3 中的3 替换即可。

### 练习九：平面上最近距离 (难度: 困难）

**point_2d**表包含一个平面内一些点（超过两个）的坐标值（x，y）。

写一条查询语句求出这些点中的最短距离并保留2位小数。

```sql
|x   | y  |
|----|----|
| -1 | -1 |
|  0 |  0 |
| -1 | -2 |
```

最短距离是1，从点（-1，-1）到点（-1，-2）。所以输出结果为：

| shortest |

1.00

```sql
+--------+
|shortest|
+--------+
|1.00    |
+--------+
```

**注意：**所有点的最大距离小于10000。

分析：假设有两个点 $(x_1, y_1)$ 和 $(x_2, y_2)$， 则两个点的距离为：$\sqrt{(x_1-x_2)^2 + (y_1-y_2)^2}$)。对于 表 point_2d 中的第一条数据，如果要求第一条数据和剩下的所有记录的距离，不太好求，这里我们换种思路：使用连接的方法

- 自身连接，一条记录可以得到4列，2个点坐标
- 求距离

```sql
-- 建表
DROP TABLE
IF EXISTS `point_2d`;

CREATE TABLE `point_2d` (
    `id` 		  integer not null primary key auto_increment,
    `x`			  integer,
	`y`			  INT
);



SELECT
	*
FROM
	point_2d;


INSERT INTO `point_2d`(`x`, `y`)
VALUES
	(-1, -1),
	(0, 0),
	(-1, -2);
	
-- 解：
WITH t AS (
	SELECT
		a.id,
		a.x 'x1',
		a.y 'y1',
		b.x 'x2',
		b.y 'y2'
	FROM
		point_2d a
	CROSS JOIN point_2d b ON (a.x != b.x OR a.y != b.y)
) SELECT
	t.*, MIN(
		ROUND(
			SQRT(
				POW((x1 - x2), 2) + POW((y1 - y2), 2)
			),
			2
		)
	) 'shortest'
FROM
	t;

+----+------+------+------+------+----------+
| id | x1   | y1   | x2   | y2   | shortest |
+----+------+------+------+------+----------+
|  3 |   -1 |   -2 |   -1 |   -1 |        1 |
+----+------+------+------+------+----------+
1 row in set (0.00 sec)
```

### 练习十：行程和用户（难度：困难）

Trips 表中存所有出租车的行程信息。每段行程有唯一键 Id，Client_Id 和 Driver_Id 是 Users 表中 Users_Id 的外键。Status 是枚举类型，枚举成员为 (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’)。

| Id   | Client_Id | Driver_Id | City_Id | Status              | Request_at |
| ---- | --------- | --------- | ------- | ------------------- | ---------- |
| 1    | 1         | 10        | 1       | completed           | 2013-10-1  |
| 2    | 2         | 11        | 1       | cancelled_by_driver | 2013-10-1  |
| 3    | 3         | 12        | 6       | completed           | 2013-10-1  |
| 4    | 4         | 13        | 6       | cancelled_by_client | 2013-10-1  |
| 5    | 1         | 10        | 1       | completed           | 2013-10-2  |
| 6    | 2         | 11        | 6       | completed           | 2013-10-2  |
| 7    | 3         | 12        | 6       | completed           | 2013-10-2  |
| 8    | 2         | 12        | 12      | completed           | 2013-10-3  |
| 9    | 3         | 10        | 12      | completed           | 2013-10-3  |
| 10   | 4         | 13        | 12      | cancelled_by_driver | 2013-10-3  |

Users 表存所有用户。每个用户有唯一键 Users_Id。Banned 表示这个用户是否被禁止，Role 则是一个表示（‘client’, ‘driver’, ‘partner’）的枚举类型。

```sql
+----------+--------+--------+
| Users_Id | Banned |  Role  |
+----------+--------+--------+
|    1     |   No   | client |
|    2     |   Yes  | client |
|    3     |   No   | client |
|    4     |   No   | client |
|    10    |   No   | driver |
|    11    |   No   | driver |
|    12    |   No   | driver |
|    13    |   No   | driver |
+----------+--------+--------+
```

写一段 SQL 语句查出**2013年10月1日**至**2013年10月3日**期间非禁止用户的取消率。基于上表，你的 SQL 语句应返回如下结果，取消率（Cancellation Rate）保留两位小数。

```sql
+------------+-------------------+
|     Day    | Cancellation Rate |
+------------+-------------------+
| 2013-10-01 |       0.33        |
| 2013-10-02 |       0.00        |
| 2013-10-03 |       0.50        |
+------------+-------------------+
```

答：

```sql
-- 建表
DROP TABLE
IF EXISTS `Users`;

CREATE TABLE `Users` (
    `user_id` 		  integer not null primary key auto_increment,
    `banned`			  VARCHAR(10),
		`role`					VARCHAR(20)
);

INSERT INTO `Users`(user_id, `banned`, `role`)
VALUES
	(1, 'No', 'client'),
	(2, 'Yes', 'client'),
	(3, 'No', 'client'),
	(4, 'No', 'client'),
	(10, 'No', 'driver'),
	(11, 'No', 'driver'),
	(12, 'No', 'driver'),
	(13, 'No', 'driver');

SELECT
	*
FROM
	users;

DROP TABLE
IF EXISTS `Trips`;

CREATE TABLE `Trips` (
    `id` 		  integer not null primary key auto_increment,
    `Client_Id`			  integer,
		`Driver_Id`				integer,
		`City_Id`					INTEGER,
		`Status`					VARCHAR(20),
		`Request_at`			date,
		 FOREIGN KEY(`Client_Id`) REFERENCES `Users`(`user_id`),
		 FOREIGN KEY(`Driver_Id`) REFERENCES `Users`(`user_id`)
);
SELECT * FROM `trips`;

INSERT INTO `Trips`(`Client_Id`, `Driver_Id`, `City_Id`, `Status`, `Request_at`)
VALUES
(1, 10, 1, 'completed', '2013-10-1'),
(2, 11, 1, 'cancelled_by_driver', '2013-10-1'),
(3, 12, 6, 'completed', '2013-10-1'),
(4, 13, 6, 'cancelled_by_client', '2013-10-1'),
(1, 10, 1, 'completed', '2013-10-2'),
(2, 11, 6, 'completed', '2013-10-2'),
(3, 12, 6, 'completed', '2013-10-2'),
(2, 12, 12, 'completed', '2013-10-3'),
(3, 10, 12, 'completed', '2013-10-3'),
(4, 13, 12, 'cancelled_by_driver', '2013-10-3');

-- 答案：
WITH t AS (
	SELECT
		t.request_at 'Day',
		t. STATUS
	FROM
		(
			SELECT
				*
			FROM
				`users`
			WHERE
				banned = 'No'
			AND role = 'client'
		) u
	INNER JOIN `trips` t ON (u.user_id = t.client_id)
	WHERE
		t.request_at >= '2013-10-01'
	AND t.request_at <= '2013-10-03'
) SELECT
	`day`,
	ROUND(
		sum(
			CASE
			WHEN t. STATUS = 'cancelled_by_client' THEN
				1
			ELSE
				0
			END
		) / count(1),
		2
	) 'cancal_rate'
FROM
	t
GROUP BY
	`day`;
	
+------------+-------------+
| Day        | cancal_rate |
+------------+-------------+
| 2013-10-01 |        0.33 |
| 2013-10-02 |        0.00 |
| 2013-10-03 |        0.00 |
+------------+-------------+
3 rows in set (0.00 sec)
```

和题目中的结果不太一样，我手动算了一下，cancelled_by_client 表示用户取消，就一条记录，因此我认为我写的代码结果是正确的，方法会了就行，数据一直都在变。

## Section B

### 练习一：行转列

假设 A B C 三位小朋友期末考试成绩如下所示：

```sql
+-----+-----------+------|
| name|   subject |score |
+-----+-----------+------|
|  A  |  chinese  |  99  |
|  A  |  math     |  98  |
|  A  |  english  |  97  |
|  B  |  chinese  |  92  |
|  B  |  math     |  91  |
|  B  |  english  |  90  |
|  C  |  chinese  |  88  |
|  C  |  math     |  87  |
|  C  |  english  |  86  |
+-----+-----------+------|
```

请使用 SQL 代码将以上成绩转换为如下格式：

```sql
+-----+-----------+------|---------|
| name|   chinese | math | english |
+-----+-----------+------|---------|
|  A  |     99    |  98  |    97   |
|  B  |     92    |  91  |    90   |
|  C  |     88    |  87  |    86   |
+-----+-----------+------|---------|
```

答：

```sql
-- 建表
DROP TABLE
IF EXISTS `score`;

CREATE TABLE `score` (
    `id` 		  INT not null primary key auto_increment,
		`name`		VARCHAR(10),
    `subject`		VARCHAR(20),
		`score`			integer
);
SELECT * FROM `score`;

INSERT INTO `score`(`name`, `subject`, `score`)
VALUES
('A', 'chinese', 99),
('A', 'math', 98),
('A', 'english', 97),
('B', 'chinese', 92),
('B', 'math', 91),
('B', 'english', 90),
('C', 'chinese', 88),
('C', 'math', 87),
('C', 'english', 86);


SELECT * FROM score;

+----+------+---------+-------+
| id | name | subject | score |
+----+------+---------+-------+
|  1 | A    | chinese |    99 |
|  2 | A    | math    |    98 |
|  3 | A    | english |    97 |
|  4 | B    | chinese |    92 |
|  5 | B    | math    |    91 |
|  6 | B    | english |    90 |
|  7 | C    | chinese |    88 |
|  8 | C    | math    |    87 |
|  9 | C    | english |    86 |
+----+------+---------+-------+
9 rows in set (0.00 sec)

-- 答：使用 case ... when sencence to achieve it 
SELECT
	`name`,
	sum(
		CASE
		WHEN s.`subject` = 'chinese' THEN
			s.score
		ELSE
			0
		END
	) 'chinese',
	sum(
		CASE
		WHEN s.`subject` = 'math' THEN
			s.score
		ELSE
			0
		END
	) 'math',
	sum(
		CASE
		WHEN s.`subject` = 'english' THEN
			s.score
		ELSE
			0
		END
	) 'english'
FROM
	`score` s
GROUP BY
	`name`;    -- 注意：使用分组

+------+---------+------+---------+
| name | chinese | math | english |
+------+---------+------+---------+
| A    |      99 |   98 |      97 |
| B    |      92 |   91 |      90 |
| C    |      88 |   87 |      86 |
+------+---------+------+---------+
3 rows in set (0.00 sec)
```

总结：行转列一般使用 sum(case...when) 语句。

### 练习二：列转行

假设 A B C 三位小朋友期末考试成绩如下所示：

```sql
+-----+-----------+------|---------|
| name|   chinese | math | english |
+-----+-----------+------|---------|
|  A  |     99    |  98  |    97   |
|  B  |     92    |  91  |    90   |
|  C  |     88    |  87  |    86   |
+-----+-----------+------|---------|
```

请使用 SQL 代码将以上成绩转换为如下格式：

```sql
+-----+-----------+------|
| name|   subject |score |
+-----+-----------+------|
|  A  |  chinese  |  99  |
|  A  |  math     |  98  |
|  A  |  english  |  97  |
|  B  |  chinese  |  92  |
|  B  |  math     |  91  |
|  B  |  english  |  90  |
|  C  |  chinese  |  88  |
|  C  |  math     |  87  |
|  C  |  english  |  86  |
+-----+-----------+------|
```

答：

```sql
DROP TABLE
IF EXISTS `s_score`;

CREATE TABLE `s_score` (
    `id` 		  INT not null primary key auto_increment,
		`name`		VARCHAR(10),
    `chinese`		INT,
		`math`			integer,
		`English`		INT
);

INSERT INTO s_score(`name`, `chinese`, `math`, `English`)
VALUES
('A', 99, 98, 97),
('B', 92, 91, 90),
('C', 88, 87, 86);

SELECT * FROM `s_score`;

+----+------+---------+------+---------+
| id | name | chinese | math | English |
+----+------+---------+------+---------+
|  1 | A    |      99 |   98 |      97 |
|  2 | B    |      92 |   91 |      90 |
|  3 | C    |      88 |   87 |      86 |
+----+------+---------+------+---------+
3 rows in set (0.00 sec)

-- 解答：
SELECT
	`name`,
	'chinese' AS 'subject',
	a.chinese 'score'
FROM
	`s_score` a
UNION ALL
SELECT
	`name`,
	'math' AS 'subject',
	a.math 'score'
FROM
	`s_score` a
UNION ALL
SELECT
	`name`,
	'english' AS 'english',
	a.english 'score'
FROM
	`s_score` a
ORDER BY NAME;

+------+---------+-------+
| name | subject | score |
+------+---------+-------+
| A    | chinese |    99 |
| A    | math    |    98 |
| A    | english |    97 |
| B    | chinese |    92 |
| B    | math    |    91 |
| B    | english |    90 |
| C    | chinese |    88 |
| C    | math    |    87 |
| C    | english |    86 |
+------+---------+-------+
9 rows in set (0.00 sec)
```

分析：列转行特点

- 列数变少
- 行数变多

此时我们应该想到 union 关键字，它可以增加行数，有多少列数，我们就可以写多上union增加行数。

### 练习三：谁是明星带货主播？

假设，某平台2021年主播带货销售额日统计数据如下：

表名 `anchor_sales`

```sql
+-------------+------------+---------|
| anchor_name |     date   |  sales  | 
+-------------+------------+---------|
|      A      |  20210101  |  40000  |
|      B      |  20210101  |  80000  |
|      A      |  20210102  |  10000  |
|      C      |  20210102  |  90000  |
|      A      |  20210103  |   7500  |
|      C      |  20210103  |  80000  |
+-------------+------------+---------|
```

定义：如果某主播的某日销售额占比达到该平台当日销售总额的 90% 及以上，则称该主播为明星主播，当天也称为明星主播日。

请使用 SQL 完成如下计算：

a. 2021年有多少个明星主播日？

```sql
SELECT
	count(1) AS '明星主播日'
FROM
	(
		WITH t AS (
			SELECT
				date,
				anchor_name,
				sales,
				SUM(sales) over w AS sum_sales
			FROM
				`anchor_sales` window w AS (PARTITION BY date)
		) SELECT
			t.*, round(sales / sum_sales, 2) rate
		FROM
			t
	) tt
WHERE
	tt.rate >= 0.9;
	
+------------+
| 明星主播日 |
+------------+
|          2 |
+------------+
1 row in set (0.00 sec)
```

b. 2021年有多少个明星主播？

```sql

SELECT
	COUNT(DISTINCT anchor_name) AS '明星主播个数' 
FROM
	(
		WITH t AS (
			SELECT
				date,
				anchor_name,
				sales,
				SUM(sales) over w AS sum_sales
			FROM
				`anchor_sales` window w AS (PARTITION BY date)
		) SELECT
			t.*, round(sales / sum_sales, 2) rate
		FROM
			t
	) tt
WHERE
	tt.rate >= 0.9
AND EXTRACT(YEAR FROM `date`) = 2021;

+--------------+
| 明星主播个数 |
+--------------+
|            1 |
+--------------+
1 row in set (0.00 sec)
```



### 练习四：MySQL 中如何查看sql语句的执行计划？可以看到哪些信息？

```sql
explain SELECT * FROM `anchor_sales`;
+----+-------------+--------------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table        | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+--------------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | anchor_sales | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    6 |   100.00 | NULL  |
+----+-------------+--------------+------------+------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

查出的表中的列名有：

- id
- select_type
- table
- partitions
- type
- possible_keys

...等等

### 练习五：解释一下 SQL 数据库中 ACID 是指什么

ACID，是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：**原子性**（atomicity，或称不可分割性）、**一致性**（consistency）、**隔离性**（isolation，又称独立性）、**持久性**（durability）。

- Atomicity（原子性）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
- Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
- Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
- Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 

## Section C

### 练习一：行转列

假设有如下比赛结果：

```sql
+--------------+-----------+
|    cdate     |   result  |
+--------------+-----------+
|  2021-01-01  |     胜    |
|  2021-01-01  |     胜    |
|  2021-01-01  |     负    |
|  2021-01-03  |     胜    |
|  2021-01-03  |     负    |
|  2021-01-03  |     负    |
+------------+-------------+
```

请使用 SQL 将比赛结果转换为如下形式：

```sql
+--------------+-----+-----|
|  比赛日期     | 胜  | 负  |
+--------------+-----------+
|  2021-01-01  |  2  |  1  |
|  2021-01-03  |  1  |  2  |
+------------+-----------+
```

解：

```sql
DROP TABLE
IF EXISTS `s_match`;

CREATE TABLE `s_match` (
    `id` 		  INT not null primary key auto_increment,
		`cdate`		date,
    `result`		VARCHAR(10)
);
SELECT * FROM `s_match`;

INSERT INTO `s_match`(`cdate`, `result`)
VALUES
('2021-01-01', '胜'),
('2021-01-01', '胜'),
('2021-01-01', '负'),
('2021-01-03', '胜'),
('2021-01-03', '负'),
('2021-01-03', '负');


SELECT * FROM score;

SELECT
	s.cdate '比赛日期',
	sum(
		CASE
		WHEN s.`result` = '胜' THEN
			1
		ELSE
			0
		END
	) '胜',
	sum(
		CASE
		WHEN s.`result` = '负' THEN
			1
		ELSE
			0
		END
	) '负'
FROM
	`s_match` s
GROUP BY
	`cdate`;
```



### 练习二：列转行

假设有如下比赛结果：

```sql
+--------------+-----+-----|
|  比赛日期     | 胜  | 负  |
+--------------+-----------+
|  2021-01-01  |  2  |  1  |
|  2021-01-03  |  1  |  2  |
+------------+-----------+
```

请使用 SQL 将比赛结果转换为如下形式：

```sql
+--------------+-----------+
|    cdate     |   result  |
+--------------+-----------+
|  2021-01-01  |     胜    |
|  2021-01-01  |     胜    |
|  2021-01-01  |     负    |
|  2021-01-03  |     胜    |
|  2021-01-03  |     负    |
|  2021-01-03  |     负    |
+------------+-------------+
```

解：

```sql
SELECT
	a.`比赛日期` AS cdate,
	SUBSTRING_INDEX(
		SUBSTRING_INDEX(

			REPEAT
				('胜,', a.`胜`),
				',',
				b.help_topic_id + 1
		),
		',' ,- 1
	) AS result
FROM
	col_row AS a
JOIN mysql.help_topic AS b ON b.help_topic_id < (
	length(REPEAT('胜,', a.`胜`)) - length(
		REPLACE (

			REPEAT
				('胜,', a.`胜`),
				',',
				''
		)
	) + 1
)
WHERE
	b.help_topic_id < a.`胜`
UNION ALL
	SELECT
		a.`比赛日期` AS cdate,
		SUBSTRING_INDEX(
			SUBSTRING_INDEX(

				REPEAT
					('负,', a.`负`),
					',',
					b.help_topic_id + 1
			),
			',' ,- 1
		) AS result
	FROM
		col_row AS a
	JOIN mysql.help_topic AS b ON b.help_topic_id < (
		length(REPEAT('负,', a.`负`)) - length(
			REPLACE (

				REPEAT
					('负,', a.`负`),
					',',
					''
			)
		) + 1
	)
	WHERE
		b.help_topic_id < a.`负`
	ORDER BY
		cdate,
		result;
```



### 练习三：连续登录

有用户表行为记录表t_act_records表，包含两个字段：uid（用户ID），imp_date（日期）

1. 计算2021年每个月，每个用户连续登录的最多天数
2. 计算2021年每个月，连续2天都有登录的用户名单
3. 计算2021年每个月，连续5天都有登录的用户数

构造表mysql如下：

```sql
DROP TABLE if EXISTS t_act_records;
CREATE TABLE t_act_records
(uid  VARCHAR(20),
imp_date DATE);

INSERT INTO t_act_records VALUES
('u1001', 20210101),
('u1002', 20210101),
('u1003', 20210101),
('u1003', 20210102),
('u1004', 20210101),
('u1004', 20210102),
('u1004', 20210103),
('u1004', 20210104),
('u1004', 20210105);
```

## 练习四：用户购买商品推荐

假设现在需要根据算法给每个 `user_id` 推荐购买商品，推荐算法比较简单，推荐和他相似的用户购买过的 `product` 即可，说明如下：

- 排除用户自己购买过的商品
- 相似用户定义：曾经购买过 2 种或 2 种以上的相同的商品

输入表：`orders`

```sql
+---------+------------+
| user_id | product_id |
+---------+------------+
|     123 |          1 |
|     123 |          2 |
|     123 |          3 |
|     456 |          1 |
|     456 |          2 |
|     456 |          4 |
+---------+------------+
```

输出表：

```sql
+---------+------------+
| user_id | product_id |
+---------+------------+
|     123 |          4 |
|     456 |          3 |
+---------+------------+
```

### 练习五：hive 数据倾斜的产生原因及优化策略？

### 练习六：LEFT JOIN 是否可能会出现多出的行？为什么？

假设 t1 表有6行（关联列 name 有2行为空），t2 表有6行（关联列 name 有3行为空）,

那么 `SELECT * FROM t1 LEFT JOIN t2 on t1.name = t2.name` 会返回多少行结果？

可以参考下图



### 写一写本次学习的收获。

感谢本课程有帮助的话，可以帮忙 `star` ~~